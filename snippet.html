<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Swirling Procedural Background</title>
    <style>
        html, body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const simplex = (() => {
        // Lightweight Simplex Noise based on https://github.com/jwagner/simplex-noise.js (MIT)
        const grad3 = [
            [1,1],[-1,1],[1,-1],[-1,-1],
            [1,0],[-1,0],[0,1],[0,-1]
        ];
        const perm = new Uint8Array(512);
        const seed = 1337;
        const rng = (function(seed) {
            return function() {
                seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5;
                return (seed < 0 ? ~seed + 1 : seed) % 256;
            };
        })(seed);
        for (let i = 0; i < 256; i++) perm[i] = rng();
        for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];

        function dot(g, x, y) { return g[0] * x + g[1] * y; }

        function noise(xin, yin) {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;
            let n0 = 0, n1 = 0, n2 = 0;

            const s = (xin + yin) * F2;
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            const t = (i + j) * G2;
            const X0 = i - t;
            const Y0 = j - t;
            const x0 = xin - X0;
            const y0 = yin - Y0;

            let i1, j1;
            if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }

            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;

            const ii = i & 255;
            const jj = j & 255;
            const gi0 = perm[ii + perm[jj]] % 8;
            const gi1 = perm[ii + i1 + perm[jj + j1]] % 8;
            const gi2 = perm[ii + 1 + perm[jj + 1]] % 8;

            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 >= 0) {
                t0 *= t0;
                n0 = t0 * t0 * dot(grad3[gi0], x0, y0);
            }

            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 >= 0) {
                t1 *= t1;
                n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
            }

            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 >= 0) {
                t2 *= t2;
                n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
            }

            return 70 * (n0 + n1 + n2);
        }

        return { noise };
    })();

    const particles = [];
    const numParticles = 5000;
    for (let i = 0; i < numParticles; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            hue: Math.random() * 360,
            life: Math.random() * 100,
        });
    }

    let t = 0;
    function animate() {
        requestAnimationFrame(animate);

        t += 0.002;

        // Fade previous frame slightly for trail effect
        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let p of particles) {
            const nx = p.x * 0.0025;
            const ny = p.y * 0.0025;
            const angle = simplex.noise(nx + t, ny + t) * Math.PI * 2;
            const speed = 0.2;

            p.x += Math.cos(angle) * speed;
            p.y += Math.sin(angle) * speed;

            // wrap around
            if (p.x < 0) p.x += canvas.width;
            if (p.y < 0) p.y += canvas.height;
            if (p.x > canvas.width) p.x -= canvas.width;
            if (p.y > canvas.height) p.y -= canvas.height;

            p.life += 1;
            if (p.life > 100) {
                p.life = 0;
                p.hue = (p.hue + 30) % 360;
            }

            ctx.fillStyle = `hsla(${p.hue}, 100%, 40%, 0.1)`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    animate();
</script>
</body>
</html>